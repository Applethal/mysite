---
disableListTemplate: True
Title: Scheduling is fun!
math: true

---
<style>
    @media (max-width: 600px) {

        .tikzs {
            width: 50%;
            padding: 10px;
        }
    }


    .tikzs {
        text-align: center;
        background-color: white;
        width: fit-content;
        margin: auto;
        padding: 20px;
        border-radius: 8px;

    }


    .dark-mode {
        background-color: #1a1a1a;
        color: #ffffff;
    }

    .code-container {
        overflow-x: auto;
        padding: 20px;
        background-color: #2d2d2d;
        color: #ffffff;
        border-radius: 10px;
        margin-top: 20px;
    }

    .code-header {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 10px;
    }

    .copy-button {
        background-color: #61dafb;

        color: #ffffff;
        padding: 8px 16px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }

    pre {
        white-space: pre-wrap;
        margin: 0;
    }

    .code-language {
        font-size: 80%;
    }

    .code-language.language-javascript {
        color: #f7df1e;

    }

    code {
        font-family: 'Courier New', monospace;
        color: #a6e22e;

    }

    @media only screen and (max-width: 600px) {
        .code-container {
            padding: 10px;
        }
    }
</style>
<link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
<script src="https://tikzjax.com/v1/tikzjax.js"></script>
<script>
    function copyCode() {
        const codeElement = document.querySelector('code');
        const textArea = document.createElement('textarea');
        textArea.value = codeElement.textContent;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
    }
</script>
<h1>intro</h1>
<p>As a guy who is very passionate about combinatorial optimization, and as much as I kept editing the core of my
    website's
    layout, I thought about adding some spiciness
    to my articles, even if it defies my minimalistic philosophies.</p>

<p>Living here in Germany slowly and subconsiously turned me into someone who embraces time, and marketers did a really
    good job at putting emphasis on it, encouraging
    goods and services that make you priorities being on time. </p>

<p>Scheduling was something that I was a fan of, the goal of their science is to find the perfect sequence of tasks that
    meets a set of requirements. Their motives may sound simple but the average scheduling puzzles are \(NP-hard\), our
    current understanding on combinatorics encourages
    the development of heuristical approaches to tackle the the hardships of investigating permutations by offering a
    solution that is good enough. </p>

<p>Cooking just began to slowly become an integral part of my life, my routine life style makes it hard for me to
    innovate, I just keep cycling through a limited set of recipes. Old habits die hard, at least they do. When I feel
    energetic, my dexterity goes top notch, enabling fast reactions
    and quick manouvers across the kitchen, but sometimes I just brute force my actions without thinking, which can
    result in a chunk of wasted time, and sometimes effort.</p>

<p>In the theory of scheduling, if a given situation is formulated properly, you may gain access to tools that may aid
    you reach your goal. This can be achieved by understanding the setup
    and trying to perceive it with intelligence, after all, the methods of logistics aim to exploit all kinds of
    information in order to fullfill an objective. I thought a lot about how to design a nice scheduling setup for a
    cooking context, not chaining tasks as quick as possible may cause your food to catch a cold. </p>
<p>After tinkering with lots of tools, I thought about simplifying the scheduling formulation, for instance, instead of
    considering setup times, I simply introduce a task that expresses these. What I will be proposing is the work of an
    amateur, as of yet: \(P \,||\, \text{prec} \,,M_{j}||\, C_{\text{max}}\).</p>


<h1>The machines setup</h1>

<p>Most of the parallel machine and single machine problems, are positioned in the NP- and P complete spectrum unlike.
    Precedence constraints are essential because you can't mix veggies before cutting them. We are aiming for the global
    completion time
    or we will be missing the train. There would be no heuristics here to speak of, just a direct method, specifically a
    list
    scheduling algorithm since it has been proven by <a
        href="https://www.sciencedirect.com/science/article/pii/0167637795000577">Shutten</a> that parallel machine
    problems with setup times or precedence constraints can be solved to optimality with the aformentioned algorithm.
    <br>
    As for the constraints here is how I dealt with some of these:
<ul>
    <li>Preemption: Instead of stopping the machine and resuming afterwards, I made it so that it is treated as \(n\)
        number of phases.</li>
    <li>Setup times: These will either be modeled as a seperate task similarly to the previous constraint, or in some
        occasions I might just combine everything in the processing times </li>

</ul>

</p>
<h1>The formulation:</h1>
<p>Before talking about the design let me define what a machine is. <b>Pretty much anything that processes a task on its
        own without any active moderation from my end.</b> My kitchen is equipped with a stove, an oven, a microwave-
    all of which can act on their own
    provided
    I initiate them - As for me, I have my own hands which will act as a medium to craft the best of the best.
    Specs-wise,
    I think the machines and I are modern enough. <br>
    As for the precedence graph, I will not go into deep detail on the chain of tasks unless it is necessary. The
    quantity of my
    descriptions should not in theory influence the makespan, so micro tasks like "breaking an egg and then mixing it
    up"
    will be
    summed up as "preparing the egg" for the sake of simplicity.

</p>


<h1>Example:</h1>

<p>Here I will be showcasing a small example of how to model the Gantt chart of preparing an omelette sandwish.

<h2>Tasks:</h2>
<ol>
    <li>

        Prepare the egg
    </li>
    <li>
        Cut the veggies
    </li>
    <li> Cook the egg </li>
    <li> Prepare the bread </li>
    <li> Stuff in the bread</li>
</ol>
</p>
<p>
<h2>Machines set:

</h2>
These will be the tasks assigned to each machine:
<ul>
    <li>Me = {1,2,4,5}</li>
    <li>Stove = {3}</li>
</ul>
</p>
<p>And these can be modeled like so, because you can't stuff anything in the bread as long as your eggs aren't ready:
</p>
<div style="text-align: center; background-color: white; width: fit-content; margin: auto; 


padding: 20px;
border-radius: 8px;">
    <script type="text/tikz">
            \begin{tikzpicture}
        
        \node (1) at (0,0) {1};
        \node (2) at (2,0){2};
        \node (3) at (4,2){3};
        \node (4) at (4,-2){4};
        \node (5) at (6,0){5};
        
        
        \draw[->, >=stealth] (1) -- (2);
        \draw[->, >=stealth] (2) -- (3);
        \draw[->, >=stealth] (2) -- (4);
        \draw[->, >=stealth] (4) -- (5);
        \draw[->, >=stealth] (3) -- (5);
    
        
        \foreach \i in {1,...,5} {
            \node[draw, circle] at (\i) {\i};
        }
    \end{tikzpicture}
          </script>
</div>

<p>I will not attribute any processing times. Check out the list scheduling algorithm for precedence graphs if you want
    to learn more about it but it should be like a walk in the park. </p>



<div class="tikzs">
    <script type="text/tikz">
        \begin{tikzpicture}[scale=0.7]
        \draw[->] (0,0) -- (14,0) node[right] {};
    \draw[->] (0,0) -- (0,7) node[above] {};
    
    
    \draw[gray!50, dashed, step=1] (0,0) grid (14,7);
    
    
    \foreach \x in {1,2,...,14} {
        \draw (\x,0) -- (\x,-0.2) node[below] {\x};
    }
    
    
    \foreach \y/\label in {3/Human, 7/Stove} {
        \draw (0,\y) -- (-0.2,\y) node[left] {\label};
    }
    \draw[fill=blue!30] (0,0) rectangle (3,3) node[pos=0.5] {Egg};
    \draw[fill=blue!30] (3,0) rectangle (5,3) node[pos=.5] {Cut};
    
    \draw[fill=blue!30] (5,3) rectangle (10,7) node[pos=.5] {Cook};
    \draw[fill=blue!30] (5,0) rectangle (8,3) node[pos=.5] {Bread};
    \draw[fill=blue!30] (10,0) rectangle (12,3) node[pos=.5] {Stuff};
    \draw[fill=red!30, line width=1.5pt] (12,0) rectangle (12,7) node[pos=1, right=2mm] {$C_{max} = 12$};

    
    \end{tikzpicture}
      </script>

</div>

<u>
    <h2>Small observation:</h2>
</u>
A couple of people pointed out that I was cooking eggs the wrong way, more specifically, I put the eggs on a pan and let
the pan do the rest @ 6/10
heat. Apparently the popular belief recommends against this and instead agitate the egg as it heats up using a pressure
tool. If that is the case then this isn't a Parallel machine schedule anymore but a single machine since I would then be
actively
doing all the cooking, increasing the total time up to 15.

<h1>About the computation</h1>


Using a solver is totally unecessary since our list algorithm method has a complexity of \(O(N)\). The following
Javascript
snippet will be plugged together with a module that generates Gantt charts, for now I am using Tikzjax but its slow
rendering speed and its lack of CSS flexibility motivates me to seek another package. The code computes the Makespan and
outputs
the starting- and finishing times of each machine, all of which are calculated using the classic formula:
$$C_{i,j} = \max\left(C_{i-1,j}, C_{i,j-1}\right) + p_{i,j}$$


The data is extracted from the recipes and formulated as a list that contains all the information that I would need.


<div class="code-container">
    <div class="code-header">
        <button class="copy-button" onclick="copyCode()">Copy Code</button>
    </div>
    <pre>
        <code>
            var processSteps = [
    {{- range $index, $task := $tasks -}}
      {
        id: {{ $task.id }},
        name: "{{ $task.name }}",
        machine: "{{ $task.machine }}",
        processing_time: {{ $task.processing_time }},
        dependencies: [{{ range $task.dependencies }}{{ . }},{{ end }}],
      },
    {{- end -}}
  ];


    function calculateSchedule(processSteps) {
        const tasks = processSteps.map((step, index) => ({
            id: index + 1,
            name: step.name,
            machine: step.machine,
            processingTime: step.processing_time,
            dependencies: step.dependencies,
            startTime: 0,
            finishTime: 0,
        }));

        for (const task of tasks) {
            task.startTime = Math.max(...task.dependencies.map(depId => tasks[depId - 1].finishTime), 0);
            task.finishTime = task.startTime + task.processingTime;
        }

        const makespan = Math.max(...tasks.map(task => task.finishTime));

        return { makespan, tasks };
    }


    const scheduleResult = calculateSchedule(processSteps);
    console.log('Makespan:', scheduleResult.makespan);
    console.log('Task Schedule:');
    scheduleResult.tasks.forEach(task => {
        console.log(`${task.name}: Start Time ${task.startTime}, Finish Time ${task.finishTime}, Machine ${task.machine}`);
    });



        </code>
    </pre>
</div>


<h1>Can a better formulation beat my makespan ?</h1>

<p>I would like to see that, Everything that you have read so far was the effort of two days and is subject for
    potential improvements. For now I am happy with the results, though if I get any new ideas, I will surely imeplement
    provide updates.</p>